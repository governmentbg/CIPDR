import{layout}from"dagre-d3-es/src/dagre/index.js";import*as graphlibJson from"dagre-d3-es/src/graphlib/json.js";import{c as createLabel,i as intersectRect,a as insertMarkers,b as clear$2,d as clear$3,u as updateNodeBounds,s as setNodeElem,e as insertNode,f as insertEdgeLabel,p as positionNode,g as insertEdge,h as positionEdgeLabel}from"./edges-0005682e.js";import{l as log,n as evaluate,c as getConfig}from"./mermaid-768dc893.js";import*as graphlib from"dagre-d3-es/src/graphlib/index.js";import{c as createText}from"./createText-3b1f58a4.js";import{select}from"d3";let clusterDb={},descendants={},parents={};const clear$1=()=>{descendants={},parents={},clusterDb={}},isDescendant=(e,t)=>(log.trace("In isDecendant",t," ",e," = ",descendants[t].includes(e)),!!descendants[t].includes(e)),edgeInCluster=(e,t)=>(log.info("Decendants of ",t," is ",descendants[t]),log.info("Edge is ",e),e.v===t?!1:e.w!==t&&(descendants[t]?descendants[t].includes(e.v)||isDescendant(e.v,t)||isDescendant(e.w,t)||descendants[t].includes(e.w):(log.debug("Tilt, ",t,",not in decendants"),!1))),copy=(n,i,a,s)=>{log.warn("Copying children of ",n,"root",s,"data",i.node(n),s);const e=i.children(n)||[];n!==s&&e.push(n),log.warn("Copying (nodes) clusterId",n,"nodes",e),e.forEach(e=>{if(0<i.children(e).length)copy(e,i,a,s);else{var t=i.node(e);log.info("cp ",e," to ",s," with parent ",n),a.setNode(e,t),s!==i.parent(e)&&(log.warn("Setting parent",e,i.parent(e)),a.setParent(e,i.parent(e))),n!==s&&e!==n?(log.debug("Setting parent",e,n),a.setParent(e,n)):(log.info("In copy ",n,"root",s,"data",i.node(n),s),log.debug("Not Setting parent for node=",e,"cluster!==rootId",n!==s,"node!==clusterId",e!==n));const r=i.edges(e);log.debug("Copying Edges",r),r.forEach(e=>{log.info("Edge",e);var t=i.edge(e.v,e.w,e.name);log.info("Edge data",t,s);try{edgeInCluster(e,s)?(log.info("Copying as ",e.v,e.w,t,e.name),a.setEdge(e.v,e.w,t,e.name),log.info("newGraph edges ",a.edges(),a.edge(a.edges()[0]))):log.info("Skipping copy of edge ",e.v,"--\x3e",e.w," rootId: ",s," clusterId:",n)}catch(e){log.error(e)}})}log.debug("Removing node",e),i.removeNode(e)})},extractDescendants=(e,t)=>{var r=t.children(e);let n=[...r];for(const i of r)parents[i]=e,n=[...n,...extractDescendants(i,t)];return n},findNonClusterChild=(e,t)=>{log.trace("Searching",e);var r=t.children(e);if(log.trace("Searching children of id ",e,r),r.length<1)return log.trace("This is a valid node",e),e;for(const i of r){var n=findNonClusterChild(i,t);if(n)return log.trace("Found replacement for",e," => ",n),n}},getAnchorId=e=>clusterDb[e]&&(clusterDb[e].externalConnections&&clusterDb[e])?clusterDb[e].id:e,adjustClustersAndEdges=(o,e)=>{!o||10<e?log.debug("Opting out, no graph "):(log.debug("Opting in, graph "),o.nodes().forEach(function(e){0<o.children(e).length&&(log.warn("Cluster identified",e," Replacement id in edges: ",findNonClusterChild(e,o)),descendants[e]=extractDescendants(e,o),clusterDb[e]={id:findNonClusterChild(e,o),clusterData:o.node(e)})}),o.nodes().forEach(function(t){var e=o.children(t);const r=o.edges();0<e.length?(log.debug("Cluster identified",t,descendants),r.forEach(e=>{e.v!==t&&e.w!==t&&isDescendant(e.v,t)^isDescendant(e.w,t)&&(log.warn("Edge: ",e," leaves cluster ",t),log.warn("Decendants of XXX ",t,": ",descendants[t]),clusterDb[t].externalConnections=!0)})):log.debug("Not a cluster ",t,descendants)}),o.edges().forEach(function(e){const t=o.edge(e);log.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),log.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(o.edge(e)));let r=e.v,n=e.w;if(log.warn("Fix XXX",clusterDb,"ids:",e.v,e.w,"Translating: ",clusterDb[e.v]," --- ",clusterDb[e.w]),clusterDb[e.v]&&clusterDb[e.w]&&clusterDb[e.v]===clusterDb[e.w]){log.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),log.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),r=getAnchorId(e.v),n=getAnchorId(e.w),o.removeEdge(e.v,e.w,e.name);var i=e.w+"---"+e.v;o.setNode(i,{domId:i,id:i,labelStyle:"",labelText:t.label,padding:0,shape:"labelRect",style:""});const a=JSON.parse(JSON.stringify(t)),s=JSON.parse(JSON.stringify(t));a.label="",a.arrowTypeEnd="none",s.label="",a.fromCluster=e.v,s.toCluster=e.v,o.setEdge(r,i,a,e.name+"-cyclic-special"),o.setEdge(i,n,s,e.name+"-cyclic-special")}else(clusterDb[e.v]||clusterDb[e.w])&&(log.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),r=getAnchorId(e.v),n=getAnchorId(e.w),o.removeEdge(e.v,e.w,e.name),r!==e.v&&(t.fromCluster=e.v),n!==e.w&&(t.toCluster=e.w),log.warn("Fix Replacing with XXX",r,n,e.name),o.setEdge(r,n,t,e.name))}),log.warn("Adjusted Graph",graphlibJson.write(o)),extractor(o,0),log.trace(clusterDb))},extractor=(t,r)=>{if(log.warn("extractor - ",r,graphlibJson.write(t),t.children("D")),10<r)log.error("Bailing out");else{var n=t.nodes();let e=!1;for(const o of n){var i=t.children(o);e=e||0<i.length}if(e){log.debug("Nodes = ",n,r);for(const d of n)if(log.debug("Extracting node",d,clusterDb,clusterDb[d]&&!clusterDb[d].externalConnections,!t.parent(d),t.node(d),t.children("D")," Depth ",r),clusterDb[d])if(!clusterDb[d].externalConnections&&t.children(d)&&0<t.children(d).length){log.warn("Cluster without external connections, without a parent and with children",d,r);let e="TB"===t.graph().rankdir?"LR":"TB";clusterDb[d]&&clusterDb[d].clusterData&&clusterDb[d].clusterData.dir&&(e=clusterDb[d].clusterData.dir,log.warn("Fixing dir",clusterDb[d].clusterData.dir,e));var a=new graphlib.Graph({multigraph:!0,compound:!0}).setGraph({rankdir:e,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});log.warn("Old graph before copy",graphlibJson.write(t)),copy(d,t,a,d),t.setNode(d,{clusterNode:!0,id:d,clusterData:clusterDb[d].clusterData,labelText:clusterDb[d].labelText,graph:a}),log.warn("New graph after copy node: (",d,")",graphlibJson.write(a)),log.debug("Old graph after copy",graphlibJson.write(t))}else log.warn("Cluster ** ",d," **not meeting the criteria !externalConnections:",!clusterDb[d].externalConnections," no parent: ",!t.parent(d)," children ",t.children(d)&&0<t.children(d).length,t.children("D"),r),log.debug(clusterDb);else log.debug("Not a cluster",d,r);n=t.nodes(),log.warn("New list of nodes",n);for(const l of n){var s=t.node(l);log.warn(" Now next level",l,s),s.clusterNode&&extractor(s.graph,r+1)}}else log.debug("Done, no node has children",t.nodes())}},sorter=(t,e)=>{if(0===e.length)return[];let r=Object.assign(e);return e.forEach(e=>{e=t.children(e),e=sorter(t,e);r=[...r,...e]}),r},sortNodesByHierarchy=e=>sorter(e,e.children()),rect=(e,t)=>{log.info("Creating subgraph rect for ",t.id,t);const r=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),n=r.insert("rect",":first-child");e=evaluate(getConfig().flowchart.htmlLabels);const i=r.insert("g").attr("class","cluster-label"),a="markdown"===t.labelType?createText(i,t.labelText,{style:t.labelStyle,useHtmlLabels:e}):i.node().appendChild(createLabel(t.labelText,t.labelStyle,void 0,!0));let s=a.getBBox();if(evaluate(getConfig().flowchart.htmlLabels)){const g=a.children[0],c=select(a);s=g.getBoundingClientRect(),c.attr("width",s.width),c.attr("height",s.height)}var o=0*t.padding,d=o/2,l=t.width<=s.width+o?s.width+o:t.width,d=(t.width<=s.width+o?t.diff=(s.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,log.trace("Data ",t,JSON.stringify(t)),n.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-l/2).attr("y",t.y-t.height/2-d).attr("width",l).attr("height",t.height+o),e?i.attr("transform","translate("+(t.x-s.width/2)+", "+(t.y-t.height/2)+")"):i.attr("transform","translate("+t.x+", "+(t.y-t.height/2)+")"),n.node().getBBox());return t.width=d.width,t.height=d.height,t.intersect=function(e){return intersectRect(t,e)},r},noteGroup=(e,t)=>{const r=e.insert("g").attr("class","note-cluster").attr("id",t.id),n=r.insert("rect",":first-child");var e=0*t.padding,i=e/2,i=(n.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-i).attr("y",t.y-t.height/2-i).attr("width",t.width+e).attr("height",t.height+e).attr("fill","none"),n.node().getBBox());return t.width=i.width,t.height=i.height,t.intersect=function(e){return intersectRect(t,e)},r},roundedWithTitle=(e,t)=>{const r=e.insert("g").attr("class",t.classes).attr("id",t.id),n=r.insert("rect",":first-child"),i=r.insert("g").attr("class","cluster-label"),a=r.append("rect"),s=i.node().appendChild(createLabel(t.labelText,t.labelStyle,void 0,!0));let o=s.getBBox();if(evaluate(getConfig().flowchart.htmlLabels)){const g=s.children[0],c=select(s);o=g.getBoundingClientRect(),c.attr("width",o.width),c.attr("height",o.height)}o=s.getBBox();var e=0*t.padding,d=e/2,l=t.width<=o.width+t.padding?o.width+t.padding:t.width,d=(t.width<=o.width+t.padding?t.diff=(o.width+0*t.padding-t.width)/2:t.diff=-t.padding/2,n.attr("class","outer").attr("x",t.x-l/2-d).attr("y",t.y-t.height/2-d).attr("width",l+e).attr("height",t.height+e),a.attr("class","inner").attr("x",t.x-l/2-d).attr("y",t.y-t.height/2-d+o.height-1).attr("width",l+e).attr("height",t.height+e-o.height-3),i.attr("transform","translate("+(t.x-o.width/2)+", "+(t.y-t.height/2-t.padding/3+(evaluate(getConfig().flowchart.htmlLabels)?5:3))+")"),n.node().getBBox());return t.height=d.height,t.intersect=function(e){return intersectRect(t,e)},r},divider=(e,t)=>{const r=e.insert("g").attr("class",t.classes).attr("id",t.id),n=r.insert("rect",":first-child");var e=0*t.padding,i=e/2,i=(n.attr("class","divider").attr("x",t.x-t.width/2-i).attr("y",t.y-t.height/2).attr("width",t.width+e).attr("height",t.height+e),n.node().getBBox());return t.width=i.width,t.height=i.height,t.diff=-t.padding/2,t.intersect=function(e){return intersectRect(t,e)},r},shapes={rect:rect,roundedWithTitle:roundedWithTitle,noteGroup:noteGroup,divider:divider};let clusterElems={};const insertCluster=(e,t)=>{log.trace("Inserting cluster");var r=t.shape||"rect";clusterElems[t.id]=shapes[r](e,t)},clear=()=>{clusterElems={}},recursiveRender=async(e,i,a,s)=>{log.info("Graph in recursive render: XXX",graphlibJson.write(i),s);const o=i.graph().rankdir,t=(log.trace("Dir in recursive render - dir:",o),e.insert("g").attr("class","root")),r=(i.nodes()?log.info("Recursive render XXX",i.nodes()):log.info("No nodes found for",i),0<i.edges().length&&log.trace("Recursive edges",i.edge(i.edges()[0])),t.insert("g").attr("class","clusters")),n=t.insert("g").attr("class","edgePaths"),d=t.insert("g").attr("class","edgeLabels"),l=t.insert("g").attr("class","nodes");await Promise.all(i.nodes().map(async function(e){const t=i.node(e);var r,n;void 0!==s&&(r=JSON.parse(JSON.stringify(s.clusterData)),log.info("Setting data for cluster XXX (",e,") ",r,s),i.setNode(s.id,r),i.parent(e)||(log.trace("Setting parent",e,s.id),i.setParent(e,s.id,r))),log.info("(Insert) Node XXX"+e+": "+JSON.stringify(i.node(e))),t&&t.clusterNode?(log.info("Cluster identified",e,t.width,i.node(e)),n=(r=await recursiveRender(l,t.graph,a,i.node(e))).elem,updateNodeBounds(t,n),t.diff=r.diff||0,log.info("Node bounds (abc123)",e,t,t.width,t.x,t.y),setNodeElem(n,t),log.warn("Recursive render complete ",n,t)):0<i.children(e).length?(log.info("Cluster - the non recursive path XXX",e,t.id,t,i),log.info(findNonClusterChild(t.id,i)),clusterDb[t.id]={id:findNonClusterChild(t.id,i),node:t}):(log.info("Node - the non recursive path",e,t.id,t),await insertNode(l,i.node(e),o))})),i.edges().forEach(function(e){var t=i.edge(e.v,e.w,e.name);log.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),log.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(i.edge(e))),log.info("Fix",clusterDb,"ids:",e.v,e.w,"Translateing: ",clusterDb[e.v],clusterDb[e.w]),insertEdgeLabel(d,t)}),i.edges().forEach(function(e){log.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e))}),log.info("#############################################"),log.info("###                Layout                 ###"),log.info("#############################################"),log.info(i),layout(i),log.info("Graph after layout:",graphlibJson.write(i));let g=0;return sortNodesByHierarchy(i).forEach(function(e){var t=i.node(e);log.info("Position "+e+": "+JSON.stringify(i.node(e))),log.info("Position "+e+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),(!t||!t.clusterNode)&&0<i.children(e).length?(insertCluster(r,t),clusterDb[t.id].node=t):positionNode(t)}),i.edges().forEach(function(e){var t=i.edge(e),e=(log.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t),t),insertEdge(n,e,t,clusterDb,a,i));positionEdgeLabel(t,e)}),i.nodes().forEach(function(e){var t=i.node(e);log.info(e,t.type,t.diff),"group"===t.type&&(g=t.diff)}),{elem:t,diff:g}},render=async(e,t,r,n,i)=>{insertMarkers(e,r,n,i),clear$2(),clear$3(),clear(),clear$1(),log.warn("Graph at first:",graphlibJson.write(t)),adjustClustersAndEdges(t),log.warn("Graph after:",graphlibJson.write(t)),await recursiveRender(e,t,n)};export{render as r};