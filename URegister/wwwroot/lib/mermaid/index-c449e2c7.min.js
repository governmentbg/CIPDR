import{b as j,i as m,m as D,G,l as A}from"./layout-df07420e.js";import{c as O,i as X,a as M,b as _,d as $,u as H,s as V,e as q,f as U,p as B,g as W,h as Y}from"./edges-6be02a86.js";import{l as i,q as N,c as E,j as L}from"./mermaid-d733041c.js";import{c as z}from"./createText-98e4790d.js";var K=4;function Q(e){return j(e,K)}function y(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:Z(e),edges:I(e)};return m(e.graph())||(t.value=Q(e.graph())),t}function Z(n){return D(n.nodes(),function(e){var t=n.node(e),i=n.parent(e),e={v:e};return m(t)||(e.value=t),m(i)||(e.parent=i),e})}function I(n){return D(n.edges(),function(e){var t=n.edge(e),i={v:e.v,w:e.w};return m(e.name)||(i.name=e.name),m(t)||(i.value=t),i})}let f={},x={},T={};const tt=()=>{x={},T={},f={}},S=(e,t)=>(i.trace("In isDecendant",t," ",e," = ",x[t].includes(e)),!!x[t].includes(e)),et=(e,t)=>(i.info("Decendants of ",t," is ",x[t]),i.info("Edge is ",e),e.v!==t&&e.w!==t&&(x[t]?x[t].includes(e.v)||S(e.v,t)||S(e.w,t)||x[t].includes(e.w):(i.debug("Tilt, ",t,",not in decendants"),!1))),J=(r,a,d,o)=>{i.warn("Copying children of ",r,"root",o,"data",a.node(r),o);const e=a.children(r)||[];r!==o&&e.push(r),i.warn("Copying (nodes) clusterId",r,"nodes",e),e.forEach(e=>{if(0<a.children(e).length)J(e,a,d,o);else{var t=a.node(e);i.info("cp ",e," to ",o," with parent ",r),d.setNode(e,t),o!==a.parent(e)&&(i.warn("Setting parent",e,a.parent(e)),d.setParent(e,a.parent(e))),r!==o&&e!==r?(i.debug("Setting parent",e,r),d.setParent(e,r)):(i.info("In copy ",r,"root",o,"data",a.node(r),o),i.debug("Not Setting parent for node=",e,"cluster!==rootId",r!==o,"node!==clusterId",e!==r));const n=a.edges(e);i.debug("Copying Edges",n),n.forEach(e=>{i.info("Edge",e);var t=a.edge(e.v,e.w,e.name);i.info("Edge data",t,o);try{et(e,o)?(i.info("Copying as ",e.v,e.w,t,e.name),d.setEdge(e.v,e.w,t,e.name),i.info("newGraph edges ",d.edges(),d.edge(d.edges()[0]))):i.info("Skipping copy of edge ",e.v,"--\x3e",e.w," rootId: ",o," clusterId:",r)}catch(e){i.error(e)}})}i.debug("Removing node",e),a.removeNode(e)})},p=(e,t)=>{var i=t.children(e);let n=[...i];for(const r of i)T[r]=e,n=[...n,...p(r,t)];return n},b=(e,t)=>{i.trace("Searching",e);var n=t.children(e);if(i.trace("Searching children of id ",e,n),n.length<1)return i.trace("This is a valid node",e),e;for(const a of n){var r=b(a,t);if(r)return i.trace("Found replacement for",e," => ",r),r}},v=e=>f[e]&&f[e].externalConnections&&f[e]?f[e].id:e,nt=(s,e)=>{!s||10<e?i.debug("Opting out, no graph "):(i.debug("Opting in, graph "),s.nodes().forEach(function(e){0<s.children(e).length&&(i.warn("Cluster identified",e," Replacement id in edges: ",b(e,s)),x[e]=p(e,s),f[e]={id:b(e,s),clusterData:s.node(e)})}),s.nodes().forEach(function(t){const e=s.children(t),n=s.edges();0<e.length?(i.debug("Cluster identified",t,x),n.forEach(e=>{e.v!==t&&e.w!==t&&S(e.v,t)^S(e.w,t)&&(i.warn("Edge: ",e," leaves cluster ",t),i.warn("Decendants of XXX ",t,": ",x[t]),f[t].externalConnections=!0)})):i.debug("Not a cluster ",t,x)}),s.edges().forEach(function(e){const t=s.edge(e);i.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(s.edge(e)));let n=e.v,r=e.w;if(i.warn("Fix XXX",f,"ids:",e.v,e.w,"Translating: ",f[e.v]," --- ",f[e.w]),f[e.v]&&f[e.w]&&f[e.v]===f[e.w]){i.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),i.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),n=v(e.v),r=v(e.w),s.removeEdge(e.v,e.w,e.name);var a=e.w+"---"+e.v;s.setNode(a,{domId:a,id:a,labelStyle:"",labelText:t.label,padding:0,shape:"labelRect",style:""});const d=JSON.parse(JSON.stringify(t)),o=JSON.parse(JSON.stringify(t));d.label="",d.arrowTypeEnd="none",o.label="",d.fromCluster=e.v,o.toCluster=e.v,s.setEdge(n,a,d,e.name+"-cyclic-special"),s.setEdge(a,r,o,e.name+"-cyclic-special")}else(f[e.v]||f[e.w])&&(i.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),n=v(e.v),r=v(e.w),s.removeEdge(e.v,e.w,e.name),n!==e.v&&(t.fromCluster=e.v),r!==e.w&&(t.toCluster=e.w),i.warn("Fix Replacing with XXX",n,r,e.name),s.setEdge(n,r,t,e.name))}),i.warn("Adjusted Graph",y(s)),R(s,0),i.trace(f))},R=(n,r)=>{if(i.warn("extractor - ",r,y(n),n.children("D")),10<r)i.error("Bailing out");else{let e=n.nodes(),t=!1;for(const s of e){var a=n.children(s);t=t||0<a.length}if(t){i.debug("Nodes = ",e,r);for(const l of e)if(i.debug("Extracting node",l,f,f[l]&&!f[l].externalConnections,!n.parent(l),n.node(l),n.children("D")," Depth ",r),f[l])if(!f[l].externalConnections&&n.children(l)&&0<n.children(l).length){i.warn("Cluster without external connections, without a parent and with children",l,r);let e="TB"===n.graph().rankdir?"LR":"TB";f[l]&&f[l].clusterData&&f[l].clusterData.dir&&(e=f[l].clusterData.dir,i.warn("Fixing dir",f[l].clusterData.dir,e));var d=new G({multigraph:!0,compound:!0}).setGraph({rankdir:e,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",y(n)),J(l,n,d,l),n.setNode(l,{clusterNode:!0,id:l,clusterData:f[l].clusterData,labelText:f[l].labelText,graph:d}),i.warn("New graph after copy node: (",l,")",y(d)),i.debug("Old graph after copy",y(n))}else i.warn("Cluster ** ",l," **not meeting the criteria !externalConnections:",!f[l].externalConnections," no parent: ",!n.parent(l)," children ",n.children(l)&&0<n.children(l).length,n.children("D"),r),i.debug(f);else i.debug("Not a cluster",l,r);e=n.nodes(),i.warn("New list of nodes",e);for(const c of e){var o=n.node(c);i.warn(" Now next level",c,o),o.clusterNode&&R(o.graph,r+1)}}else i.debug("Done, no node has children",n.nodes())}},P=(t,e)=>{if(0===e.length)return[];let i=Object.assign(e);return e.forEach(e=>{e=t.children(e),e=P(t,e);i=[...i,...e]}),i},it=e=>P(e,e.children()),st=(e,t)=>{i.info("Creating subgraph rect for ",t.id,t);const n=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),r=n.insert("rect",":first-child"),a=N(E().flowchart.htmlLabels),d=n.insert("g").attr("class","cluster-label"),o="markdown"===t.labelType?z(d,t.labelText,{style:t.labelStyle,useHtmlLabels:a}):d.node().appendChild(O(t.labelText,t.labelStyle,void 0,!0));let s=o.getBBox();if(N(E().flowchart.htmlLabels)){const h=o.children[0],g=L(o);s=h.getBoundingClientRect(),g.attr("width",s.width),g.attr("height",s.height)}var e=0*t.padding,l=e/2,c=t.width<=s.width+e?s.width+e:t.width,l=(t.width<=s.width+e?t.diff=(s.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,i.trace("Data ",t,JSON.stringify(t)),r.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-c/2).attr("y",t.y-t.height/2-l).attr("width",c).attr("height",t.height+e),a?d.attr("transform","translate("+(t.x-s.width/2)+", "+(t.y-t.height/2)+")"):d.attr("transform","translate("+t.x+", "+(t.y-t.height/2)+")"),r.node().getBBox());return t.width=l.width,t.height=l.height,t.intersect=function(e){return X(t,e)},n},rt=(e,t)=>{const i=e.insert("g").attr("class","note-cluster").attr("id",t.id),n=i.insert("rect",":first-child"),r=0*t.padding,a=r/2;n.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2-a).attr("width",t.width+r).attr("height",t.height+r).attr("fill","none");e=n.node().getBBox();return t.width=e.width,t.height=e.height,t.intersect=function(e){return X(t,e)},i},at=(e,t)=>{const i=e.insert("g").attr("class",t.classes).attr("id",t.id),n=i.insert("rect",":first-child"),r=i.insert("g").attr("class","cluster-label"),a=i.append("rect"),d=r.node().appendChild(O(t.labelText,t.labelStyle,void 0,!0));let o=d.getBBox();if(N(E().flowchart.htmlLabels)){const c=d.children[0],h=L(d);o=c.getBoundingClientRect(),h.attr("width",o.width),h.attr("height",o.height)}o=d.getBBox();var e=0*t.padding,s=e/2,l=t.width<=o.width+t.padding?o.width+t.padding:t.width,s=(t.width<=o.width+t.padding?t.diff=(o.width+0*t.padding-t.width)/2:t.diff=-t.padding/2,n.attr("class","outer").attr("x",t.x-l/2-s).attr("y",t.y-t.height/2-s).attr("width",l+e).attr("height",t.height+e),a.attr("class","inner").attr("x",t.x-l/2-s).attr("y",t.y-t.height/2-s+o.height-1).attr("width",l+e).attr("height",t.height+e-o.height-3),r.attr("transform","translate("+(t.x-o.width/2)+", "+(t.y-t.height/2-t.padding/3+(N(E().flowchart.htmlLabels)?5:3))+")"),n.node().getBBox());return t.height=s.height,t.intersect=function(e){return X(t,e)},i},ct=(e,t)=>{const i=e.insert("g").attr("class",t.classes).attr("id",t.id),n=i.insert("rect",":first-child"),r=0*t.padding,a=r/2;n.attr("class","divider").attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2).attr("width",t.width+r).attr("height",t.height+r);e=n.node().getBBox();return t.width=e.width,t.height=e.height,t.diff=-t.padding/2,t.intersect=function(e){return X(t,e)},i},ot={rect:st,roundedWithTitle:at,noteGroup:rt,divider:ct};let F={};const lt=(e,t)=>{i.trace("Inserting cluster");var n=t.shape||"rect";F[t.id]=ot[n](e,t)},ft=()=>{F={}},k=async(e,a,d,o)=>{i.info("Graph in recursive render: XXX",y(a),o);const s=a.graph().rankdir,t=(i.trace("Dir in recursive render - dir:",s),e.insert("g").attr("class","root")),n=(a.nodes()?i.info("Recursive render XXX",a.nodes()):i.info("No nodes found for",a),0<a.edges().length&&i.trace("Recursive edges",a.edge(a.edges()[0])),t.insert("g").attr("class","clusters")),r=t.insert("g").attr("class","edgePaths"),l=t.insert("g").attr("class","edgeLabels"),c=t.insert("g").attr("class","nodes");await Promise.all(a.nodes().map(async function(e){const t=a.node(e);var n,r;void 0!==o&&(n=JSON.parse(JSON.stringify(o.clusterData)),i.info("Setting data for cluster XXX (",e,") ",n,o),a.setNode(o.id,n),a.parent(e)||(i.trace("Setting parent",e,o.id),a.setParent(e,o.id,n))),i.info("(Insert) Node XXX"+e+": "+JSON.stringify(a.node(e))),t&&t.clusterNode?(i.info("Cluster identified",e,t.width,a.node(e)),r=(n=await k(c,t.graph,d,a.node(e))).elem,H(t,r),t.diff=n.diff||0,i.info("Node bounds (abc123)",e,t,t.width,t.x,t.y),V(r,t),i.warn("Recursive render complete ",r,t)):0<a.children(e).length?(i.info("Cluster - the non recursive path XXX",e,t.id,t,a),i.info(b(t.id,a)),f[t.id]={id:b(t.id,a),node:t}):(i.info("Node - the non recursive path",e,t.id,t),await q(c,a.node(e),s))})),a.edges().forEach(function(e){var t=a.edge(e.v,e.w,e.name);i.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(a.edge(e))),i.info("Fix",f,"ids:",e.v,e.w,"Translateing: ",f[e.v],f[e.w]),U(l,t)}),a.edges().forEach(function(e){i.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e))}),i.info("#############################################"),i.info("###                Layout                 ###"),i.info("#############################################"),i.info(a),A(a),i.info("Graph after layout:",y(a));let h=0;return it(a).forEach(function(e){var t=a.node(e);i.info("Position "+e+": "+JSON.stringify(a.node(e))),i.info("Position "+e+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),(!t||!t.clusterNode)&&0<a.children(e).length?(lt(n,t),f[t.id].node=t):B(t)}),a.edges().forEach(function(e){var t=a.edge(e),e=(i.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t),t),W(r,e,t,f,d,a));Y(t,e)}),a.nodes().forEach(function(e){var t=a.node(e);i.info(e,t.type,t.diff),"group"===t.type&&(h=t.diff)}),{elem:t,diff:h}},gt=async(e,t,n,r,a)=>{M(e,n,r,a),_(),$(),ft(),tt(),i.warn("Graph at first:",y(t)),nt(t),i.warn("Graph after:",y(t)),await k(e,t,r)};export{gt as r};